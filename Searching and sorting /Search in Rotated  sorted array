// lc  33. Search in Rotated Sorted Array
// class Solution {
// public:
// int findPivotindex(vector<int>& nums){
//     int n= nums.size();
//     int s = 0;
//     int e =n-1;
//     int mid = s+ (e-s)/2;

//     while(s<= e){
//         // corner case single element
//         if (s==e){
//             return s;
//         }
//          // galti karenge as mid +1 can be out of range
//          if( mid +1 < n && nums[mid]>nums[mid+1]){
//             return mid;
//         }
//         // galti karenge as mid -1 can be out of range
//         else if(mid -1 >= 0 && nums[mid]<nums[mid-1]){
//             return mid -1;
//         }
        
        
//         else if(nums[s]<nums[mid]){
//             e = mid-1;
//         }
//         else{
//             s = mid + 1;
//         }
//        mid = s+(e-s)/2;
//     }
//     return -1; 
// }

// int binarySearch (vector<int>& nums, int s, int e,int target){
//     int mid = s+(e-s)/2;
//     while(s<= e){
//         if(nums[mid] == target){
//             return mid;
        
//         }
//         if(target > nums[mid]){
//             s = mid+1;
//         }
//         else {
//             e = mid-1;
   
//         }
//             mid =  s+(e-s)/2;
//     }
//      return -1;

// } 

//  int search(vector<int>& nums, int target){

//    int pivotIndex = findPivotindex(nums);
//    int n = nums.size();
//    int ans = -1;

//    //searching in A
//    if(target >= nums[0] && target <= nums[pivotIndex]){
//         ans =binarySearch(nums,0,pivotIndex,target);
//    }
//    else{
//         ans =binarySearch(nums,pivotIndex+1,n-1,target);
//    }
//      return ans;
//  } 
// };
